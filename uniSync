#!/bin/sh
SCRIPT="$(cd "${0%/*}" 2>/dev/null; echo "$PWD"/"${0##*/}")"
DIR=`dirname "${SCRIPT}"}`
exec scala $0 $DIR $SCRIPT $@
::!#

/** Usage:
  *  uniSync /path/to/srcDir /path/to/destDir
  *
  */

import java.io.{File => JFile}
import java.io.{FileWriter, PrintWriter}
import scala.io.Source

object App {
  def main(args: Array[String]): Unit = {

    val files = args.map(new JFile(_))
    val currentDir = files(0)
    val sourceDir = files(2)
    val destDir = files(3)

    println("You called uniSync inside of directory: " + currentDir)
    val dotUnisync = new JFile(currentDir, ".unisync");
    if (!dotUnisync.exists) {
      println("Creating a new .unisync file in current directory...")
      initialize(sourceDir, dotUnisync)
      println("uniSync initialized. Run uniSync again to actually do your uni-directional sync.")
      return
    } else println("Reusing .unisync file in current directory...")
    println("Running uniSync with source dir: %s, and destination dir: %s.\n".format(sourceDir, destDir))

    // figure out the difference between the last run of uniSync and the current run
    val previousFileList = Source.fromFile(dotUnisync.getAbsolutePath).getLines.toList
    val currentFileList = mkFileList(sourceDir)

    val deletedFiles = previousFileList filter { prevFile =>
      !currentFileList.exists(file => file.getAbsolutePath == prevFile)
    }

    if (deletedFiles.isEmpty) println("No files have been removed since last run.")
    else {
      println(deletedFiles.length + " files removed from source directory. Removing the following files from destination directory...")
      deletedFiles foreach { fileName =>
        val corrsep = findCorrespondingInDestDir(sourceDir, destDir, new JFile(fileName))
        println(corrsep.getAbsolutePath)
      }
    }



    println("\n\nPreviously:")
    previousFileList foreach println

    println("\n\nCurrently:")
    currentFileList foreach println


    // findCorrespondingInDestDir(sourceDir, destDir, new JFile("/Users/hmiller/Desktop/test/a/2.scala")).getAbsolutePath

  }

  def findCorrespondingInDestDir(sourceDir: JFile, destDir: JFile, file: JFile): JFile = {
    val relativePath = file.getAbsolutePath.drop(sourceDir.getAbsolutePath.length + 1)
    val destFile = new JFile(destDir, relativePath)
    destFile
  }

  def initialize(sourceDir: JFile, dotUnisync: JFile) = {
    check(sourceDir)
    val fileList = mkFileList(sourceDir)
    val writer = new PrintWriter(new FileWriter(dotUnisync))

    // output file list to newly-created .unisync file
    fileList foreach (file => writer.println(file.getAbsolutePath))
    writer.close
  }

  /** Lists all the files contained in `dir` and, recursively, the children of `dir`.
    * Note that this contains only files, and not directories.
    */
  def mkFileList(dir: JFile): Array[JFile] = {
      val children = if (dir.isDirectory) {
        dir.listFiles
      } else Array[JFile]()

      val fileList =
        if (dir.isDirectory) children.flatMap(child => mkFileList(child))
        else Array(dir)

      fileList
  }

  def check(file: JFile): Unit = if (!file.exists) sys.error("Provided path to directory, "+file.getAbsolutePath+" doesn't exist")
}


// class DirectoryCloner(dir: String) {

//   val root = new JFile(dir)
//   check(root)

//   println("this is the dir: "+dir)

//   private val scratchIgnore = new JFile(dir+"/.scratchignore")
//   var ignore: List[String] = if (scratchIgnore.exists) makeIgnoreList(scratchIgnore) else List()
//   ignore = ".scratchignore" :: "_site" :: ignore

//   val siteDir = new JFile(dir+"/_site")
//   if (!siteDir.exists) siteDir.mkdir()

//   def cloneDir(file: JFile = root, offset: String = ""): Unit = {
//     val children = file.listFiles
//     println(children.mkString("\n"))
//     val okChildren = children.filterNot(f => ignore.contains(f.getName)) //FIXME: need to be able to list files and extensions
//     println("filtered children:")
//     println(okChildren.mkString("\n"))

//     okChildren.foreach{c =>
//       val f = new JFile(dir+"/_site"+offset+"/"+c.getName)
//       f.mkdir()
//       val newOffset = offset+"/"+c.getName
//       cloneDir(c, newOffset)
//     }
//   }

//   def check(file: JFile): Unit = if (!file.exists) sys.error("Provided path to directory, "+file.getAbsolutePath+" doesn't exist")
//   def makeIgnoreList(file: JFile): List[String] = Source.fromFile(file).getLines.toList

//   //def traverse(dir: Directory): Unit = { /* do nothing for now */ }
// }